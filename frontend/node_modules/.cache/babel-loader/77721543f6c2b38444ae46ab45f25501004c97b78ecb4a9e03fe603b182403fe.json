{"ast":null,"code":"import axios from\"axios\";// 디버깅용: JWT Payload 디코드 (개발 중 확인 목적)\nconst decodeJwt=bearerToken=>{try{if(!bearerToken)return null;const token=bearerToken.replace(/^Bearer\\s+/i,\"\");const payload=token.split(\".\")[1];return JSON.parse(atob(payload));}catch(e){return null;}};/**\n* ✅ AccessToken 재발급 함수\n* RefreshToken을 이용해 새로운 AccessToken을 발급받습니다.\n*/const refreshAccessToken=async()=>{try{const refreshToken=localStorage.getItem(\"Authorization-refresh\");if(!refreshToken)throw new Error(\"refreshToken 없음\");const response=await axios.post(\"/auth/refresh\",{},{baseURL:\"http://localhost:8090\",headers:{\"Authorization-refresh\":refreshToken},// JWT 헤더 기반 인증만 사용하므로 쿠키 전송 비활성화\nwithCredentials:false});// 디버깅: 새 토큰 페이로드 출력\nconst newAccessToken=response.data.accessToken;const payload=decodeJwt(\"Bearer \".concat(newAccessToken));console.log(\"[auth] refreshed access token payload:\",payload);return newAccessToken;}catch(error){console.error(\"❌ refreshToken 갱신 실패:\",error);throw error;}};/**\n* ✅ Axios 공통 인스턴스\n*/const instance=axios.create({baseURL:\"http://localhost:8090\",// JWT 헤더 기반 인증을 사용하므로 쿠키 전송을 비활성화하여 CSRF 403 가능성 제거\nwithCredentials:false});/**\n* ✅ 요청 인터셉터\n* 모든 요청에 AccessToken 자동 포함\n*/instance.interceptors.request.use(config=>{const token=localStorage.getItem(\"Authorization\");if(token){config.headers[\"Authorization\"]=token;// ex) \"Bearer eyJ...\"\n// 디버깅: 요청 시 토큰 페이로드 확인\nconst payload=decodeJwt(token);if(payload){console.log(\"[auth] request jwt payload:\",payload);}}return config;},error=>Promise.reject(error));/**\n* ✅ 응답 인터셉터\n* 401(Unauthorized) 발생 시 AccessToken 재발급 처리\n*/instance.interceptors.response.use(response=>response,async error=>{const originalRequest=error.config;/**\n    * 1️⃣ 로그인/회원가입/아이디찾기 등 비인증 요청은 예외처리\n    * -> 세션 만료 메시지 표시 X\n    */const unauthenticatedEndpoints=[\"/login\",\"/signup\",\"/find-account\"];if(unauthenticatedEndpoints.some(url=>originalRequest.url.includes(url))){return Promise.reject(error);// 그대로 Login.jsx 등으로 전달\n}/**\n    * 2️⃣ AccessToken 만료로 인한 401 에러 처리\n    */if(error.response&&error.response.status===401&&!originalRequest._retry){originalRequest._retry=true;try{// AccessToken 재발급\nconst newAccessToken=await refreshAccessToken();const bearerToken=\"Bearer \".concat(newAccessToken);// 새 토큰 저장\nlocalStorage.setItem(\"Authorization\",bearerToken);// 요청 헤더 갱신\noriginalRequest.headers[\"Authorization\"]=bearerToken;if(originalRequest.data instanceof FormData&&!originalRequest.headers[\"Content-Type\"]){originalRequest.headers[\"Content-Type\"]=\"multipart/form-data\";}// ✅ 재요청 실행 (403 발생 시 권한 부족 가능성 높음)\nreturn instance(originalRequest);}catch(refreshError){console.error(\"❌ refreshToken 재발급 실패:\",refreshError);localStorage.removeItem(\"Authorization\");localStorage.removeItem(\"Authorization-refresh\");localStorage.removeItem(\"userId\");localStorage.removeItem(\"userName\");localStorage.removeItem(\"roleCd\");localStorage.removeItem(\"isLogin\");console.error(\"세션이 만료되었습니다. 다시 로그인해주세요.\");return Promise.reject(refreshError);}}// 403인 경우: 인증은 되었으나 권한 부족(AccessDenied) 가능성이 높음\nif(error.response&&error.response.status===403){console.warn(\"[auth] 403 Forbidden: 권한 부족 또는 서버 인가 규칙 미스매치 가능성\");}return Promise.reject(error);});export default instance;","map":{"version":3,"names":["axios","decodeJwt","bearerToken","token","replace","payload","split","JSON","parse","atob","e","refreshAccessToken","refreshToken","localStorage","getItem","Error","response","post","baseURL","headers","withCredentials","newAccessToken","data","accessToken","concat","console","log","error","instance","create","interceptors","request","use","config","Promise","reject","originalRequest","unauthenticatedEndpoints","some","url","includes","status","_retry","setItem","FormData","refreshError","removeItem","warn"],"sources":["D:/Medical AI/2nd_project_STrio/frontend/src/token/interceptors.js"],"sourcesContent":["import axios from \"axios\";\n\n// 디버깅용: JWT Payload 디코드 (개발 중 확인 목적)\nconst decodeJwt = (bearerToken) => {\n    try {\n        if (!bearerToken) return null;\n        const token = bearerToken.replace(/^Bearer\\s+/i, \"\");\n        const payload = token.split(\".\")[1];\n        return JSON.parse(atob(payload));\n    } catch (e) {\n        return null;\n    }\n};\n\n/**\n* ✅ AccessToken 재발급 함수\n* RefreshToken을 이용해 새로운 AccessToken을 발급받습니다.\n*/\nconst refreshAccessToken = async () => {\ntry {\n    const refreshToken = localStorage.getItem(\"Authorization-refresh\");\n    if (!refreshToken) throw new Error(\"refreshToken 없음\");\n\n    const response = await axios.post(\n    \"/auth/refresh\",\n    {},\n    {\n        baseURL: \"http://localhost:8090\",\n        headers: {\n        \"Authorization-refresh\": refreshToken,\n        },\n        // JWT 헤더 기반 인증만 사용하므로 쿠키 전송 비활성화\n        withCredentials: false,\n    }\n    );\n\n    // 디버깅: 새 토큰 페이로드 출력\n    const newAccessToken = response.data.accessToken;\n    const payload = decodeJwt(`Bearer ${newAccessToken}`);\n    console.log(\"[auth] refreshed access token payload:\", payload);\n\n    return newAccessToken;\n} catch (error) {\n    console.error(\"❌ refreshToken 갱신 실패:\", error);\n    throw error;\n}\n};\n\n/**\n* ✅ Axios 공통 인스턴스\n*/\nconst instance = axios.create({\nbaseURL: \"http://localhost:8090\",\n// JWT 헤더 기반 인증을 사용하므로 쿠키 전송을 비활성화하여 CSRF 403 가능성 제거\nwithCredentials: false,\n});\n\n/**\n* ✅ 요청 인터셉터\n* 모든 요청에 AccessToken 자동 포함\n*/\ninstance.interceptors.request.use(\n(config) => {\n    const token = localStorage.getItem(\"Authorization\");\n    if (token) {\n    config.headers[\"Authorization\"] = token; // ex) \"Bearer eyJ...\"\n    \n        // 디버깅: 요청 시 토큰 페이로드 확인\n        const payload = decodeJwt(token);\n        if (payload) {\n            console.log(\"[auth] request jwt payload:\", payload);\n        }\n    }\n    return config;\n},\n(error) => Promise.reject(error)\n);\n\n/**\n* ✅ 응답 인터셉터\n* 401(Unauthorized) 발생 시 AccessToken 재발급 처리\n*/\ninstance.interceptors.response.use(\n(response) => response,\nasync (error) => {\n    const originalRequest = error.config;\n\n    /**\n    * 1️⃣ 로그인/회원가입/아이디찾기 등 비인증 요청은 예외처리\n    * -> 세션 만료 메시지 표시 X\n    */\n    const unauthenticatedEndpoints = [\"/login\", \"/signup\", \"/find-account\"];\n    if (unauthenticatedEndpoints.some((url) => originalRequest.url.includes(url))) {\n    return Promise.reject(error); // 그대로 Login.jsx 등으로 전달\n    }\n\n    /**\n    * 2️⃣ AccessToken 만료로 인한 401 에러 처리\n    */\n    if (\n    error.response &&\n    error.response.status === 401 &&\n    !originalRequest._retry\n    ) {\n    originalRequest._retry = true;\n\n    try {\n        // AccessToken 재발급\n        const newAccessToken = await refreshAccessToken();\n        const bearerToken = `Bearer ${newAccessToken}`;\n\n        // 새 토큰 저장\n        localStorage.setItem(\"Authorization\", bearerToken);\n\n        // 요청 헤더 갱신\n        originalRequest.headers[\"Authorization\"] = bearerToken;\n        if (\n        originalRequest.data instanceof FormData &&\n        !originalRequest.headers[\"Content-Type\"]\n        ) {\n        originalRequest.headers[\"Content-Type\"] = \"multipart/form-data\";\n        }\n\n        // ✅ 재요청 실행 (403 발생 시 권한 부족 가능성 높음)\n        return instance(originalRequest);\n    } catch (refreshError) {\n        console.error(\"❌ refreshToken 재발급 실패:\", refreshError);\n\n        localStorage.removeItem(\"Authorization\");\n        localStorage.removeItem(\"Authorization-refresh\");\n        localStorage.removeItem(\"userId\");\n        localStorage.removeItem(\"userName\");\n        localStorage.removeItem(\"roleCd\");\n        localStorage.removeItem(\"isLogin\");\n\n        console.error(\"세션이 만료되었습니다. 다시 로그인해주세요.\");\n\n        return Promise.reject(refreshError);\n    }\n    }\n\n        // 403인 경우: 인증은 되었으나 권한 부족(AccessDenied) 가능성이 높음\n        if (error.response && error.response.status === 403) {\n            console.warn(\"[auth] 403 Forbidden: 권한 부족 또는 서버 인가 규칙 미스매치 가능성\");\n        }\n\n        return Promise.reject(error);\n}\n);\n\nexport default instance;"],"mappings":"AAAA,MAAO,CAAAA,KAAK,KAAM,OAAO,CAEzB;AACA,KAAM,CAAAC,SAAS,CAAIC,WAAW,EAAK,CAC/B,GAAI,CACA,GAAI,CAACA,WAAW,CAAE,MAAO,KAAI,CAC7B,KAAM,CAAAC,KAAK,CAAGD,WAAW,CAACE,OAAO,CAAC,aAAa,CAAE,EAAE,CAAC,CACpD,KAAM,CAAAC,OAAO,CAAGF,KAAK,CAACG,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CACnC,MAAO,CAAAC,IAAI,CAACC,KAAK,CAACC,IAAI,CAACJ,OAAO,CAAC,CAAC,CACpC,CAAE,MAAOK,CAAC,CAAE,CACR,MAAO,KAAI,CACf,CACJ,CAAC,CAED;AACA;AACA;AACA,EACA,KAAM,CAAAC,kBAAkB,CAAG,KAAAA,CAAA,GAAY,CACvC,GAAI,CACA,KAAM,CAAAC,YAAY,CAAGC,YAAY,CAACC,OAAO,CAAC,uBAAuB,CAAC,CAClE,GAAI,CAACF,YAAY,CAAE,KAAM,IAAI,CAAAG,KAAK,CAAC,iBAAiB,CAAC,CAErD,KAAM,CAAAC,QAAQ,CAAG,KAAM,CAAAhB,KAAK,CAACiB,IAAI,CACjC,eAAe,CACf,CAAC,CAAC,CACF,CACIC,OAAO,CAAE,uBAAuB,CAChCC,OAAO,CAAE,CACT,uBAAuB,CAAEP,YACzB,CAAC,CACD;AACAQ,eAAe,CAAE,KACrB,CACA,CAAC,CAED;AACA,KAAM,CAAAC,cAAc,CAAGL,QAAQ,CAACM,IAAI,CAACC,WAAW,CAChD,KAAM,CAAAlB,OAAO,CAAGJ,SAAS,WAAAuB,MAAA,CAAWH,cAAc,CAAE,CAAC,CACrDI,OAAO,CAACC,GAAG,CAAC,wCAAwC,CAAErB,OAAO,CAAC,CAE9D,MAAO,CAAAgB,cAAc,CACzB,CAAE,MAAOM,KAAK,CAAE,CACZF,OAAO,CAACE,KAAK,CAAC,uBAAuB,CAAEA,KAAK,CAAC,CAC7C,KAAM,CAAAA,KAAK,CACf,CACA,CAAC,CAED;AACA;AACA,EACA,KAAM,CAAAC,QAAQ,CAAG5B,KAAK,CAAC6B,MAAM,CAAC,CAC9BX,OAAO,CAAE,uBAAuB,CAChC;AACAE,eAAe,CAAE,KACjB,CAAC,CAAC,CAEF;AACA;AACA;AACA,EACAQ,QAAQ,CAACE,YAAY,CAACC,OAAO,CAACC,GAAG,CAChCC,MAAM,EAAK,CACR,KAAM,CAAA9B,KAAK,CAAGU,YAAY,CAACC,OAAO,CAAC,eAAe,CAAC,CACnD,GAAIX,KAAK,CAAE,CACX8B,MAAM,CAACd,OAAO,CAAC,eAAe,CAAC,CAAGhB,KAAK,CAAE;AAErC;AACA,KAAM,CAAAE,OAAO,CAAGJ,SAAS,CAACE,KAAK,CAAC,CAChC,GAAIE,OAAO,CAAE,CACToB,OAAO,CAACC,GAAG,CAAC,6BAA6B,CAAErB,OAAO,CAAC,CACvD,CACJ,CACA,MAAO,CAAA4B,MAAM,CACjB,CAAC,CACAN,KAAK,EAAKO,OAAO,CAACC,MAAM,CAACR,KAAK,CAC/B,CAAC,CAED;AACA;AACA;AACA,EACAC,QAAQ,CAACE,YAAY,CAACd,QAAQ,CAACgB,GAAG,CACjChB,QAAQ,EAAKA,QAAQ,CACtB,KAAO,CAAAW,KAAK,EAAK,CACb,KAAM,CAAAS,eAAe,CAAGT,KAAK,CAACM,MAAM,CAEpC;AACJ;AACA;AACA,MACI,KAAM,CAAAI,wBAAwB,CAAG,CAAC,QAAQ,CAAE,SAAS,CAAE,eAAe,CAAC,CACvE,GAAIA,wBAAwB,CAACC,IAAI,CAAEC,GAAG,EAAKH,eAAe,CAACG,GAAG,CAACC,QAAQ,CAACD,GAAG,CAAC,CAAC,CAAE,CAC/E,MAAO,CAAAL,OAAO,CAACC,MAAM,CAACR,KAAK,CAAC,CAAE;AAC9B,CAEA;AACJ;AACA,MACI,GACAA,KAAK,CAACX,QAAQ,EACdW,KAAK,CAACX,QAAQ,CAACyB,MAAM,GAAK,GAAG,EAC7B,CAACL,eAAe,CAACM,MAAM,CACrB,CACFN,eAAe,CAACM,MAAM,CAAG,IAAI,CAE7B,GAAI,CACA;AACA,KAAM,CAAArB,cAAc,CAAG,KAAM,CAAAV,kBAAkB,CAAC,CAAC,CACjD,KAAM,CAAAT,WAAW,WAAAsB,MAAA,CAAaH,cAAc,CAAE,CAE9C;AACAR,YAAY,CAAC8B,OAAO,CAAC,eAAe,CAAEzC,WAAW,CAAC,CAElD;AACAkC,eAAe,CAACjB,OAAO,CAAC,eAAe,CAAC,CAAGjB,WAAW,CACtD,GACAkC,eAAe,CAACd,IAAI,WAAY,CAAAsB,QAAQ,EACxC,CAACR,eAAe,CAACjB,OAAO,CAAC,cAAc,CAAC,CACtC,CACFiB,eAAe,CAACjB,OAAO,CAAC,cAAc,CAAC,CAAG,qBAAqB,CAC/D,CAEA;AACA,MAAO,CAAAS,QAAQ,CAACQ,eAAe,CAAC,CACpC,CAAE,MAAOS,YAAY,CAAE,CACnBpB,OAAO,CAACE,KAAK,CAAC,wBAAwB,CAAEkB,YAAY,CAAC,CAErDhC,YAAY,CAACiC,UAAU,CAAC,eAAe,CAAC,CACxCjC,YAAY,CAACiC,UAAU,CAAC,uBAAuB,CAAC,CAChDjC,YAAY,CAACiC,UAAU,CAAC,QAAQ,CAAC,CACjCjC,YAAY,CAACiC,UAAU,CAAC,UAAU,CAAC,CACnCjC,YAAY,CAACiC,UAAU,CAAC,QAAQ,CAAC,CACjCjC,YAAY,CAACiC,UAAU,CAAC,SAAS,CAAC,CAElCrB,OAAO,CAACE,KAAK,CAAC,0BAA0B,CAAC,CAEzC,MAAO,CAAAO,OAAO,CAACC,MAAM,CAACU,YAAY,CAAC,CACvC,CACA,CAEI;AACA,GAAIlB,KAAK,CAACX,QAAQ,EAAIW,KAAK,CAACX,QAAQ,CAACyB,MAAM,GAAK,GAAG,CAAE,CACjDhB,OAAO,CAACsB,IAAI,CAAC,kDAAkD,CAAC,CACpE,CAEA,MAAO,CAAAb,OAAO,CAACC,MAAM,CAACR,KAAK,CAAC,CACpC,CACA,CAAC,CAED,cAAe,CAAAC,QAAQ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}