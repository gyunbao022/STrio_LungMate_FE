{"ast":null,"code":"import axios from \"axios\";\n\n// 디버깅용: JWT Payload 디코드 (개발 중 확인 목적)\nconst decodeJwt = bearerToken => {\n  try {\n    if (!bearerToken) return null;\n    const token = bearerToken.replace(/^Bearer\\s+/i, \"\");\n    const payload = token.split(\".\")[1];\n    return JSON.parse(atob(payload));\n  } catch (e) {\n    return null;\n  }\n};\n\n/**\r\n* ✅ AccessToken 재발급 함수\r\n* RefreshToken을 이용해 새로운 AccessToken을 발급받습니다.\r\n*/\nconst refreshAccessToken = async () => {\n  try {\n    const refreshToken = localStorage.getItem(\"Authorization-refresh\");\n    if (!refreshToken) throw new Error(\"refreshToken 없음\");\n    const response = await axios.post(\"/auth/refresh\", {}, {\n      baseURL: \"http://localhost:8090\",\n      headers: {\n        \"Authorization-refresh\": refreshToken\n      },\n      // JWT 헤더 기반 인증만 사용하므로 쿠키 전송 비활성화\n      withCredentials: false\n    });\n\n    // 디버깅: 새 토큰 페이로드 출력\n    const newAccessToken = response.data.accessToken;\n    const payload = decodeJwt(`Bearer ${newAccessToken}`);\n    console.log(\"[auth] refreshed access token payload:\", payload);\n    return newAccessToken;\n  } catch (error) {\n    console.error(\"❌ refreshToken 갱신 실패:\", error);\n    throw error;\n  }\n};\n\n/**\r\n* ✅ Axios 공통 인스턴스\r\n*/\nconst instance = axios.create({\n  baseURL: \"http://localhost:8090\",\n  // JWT 헤더 기반 인증을 사용하므로 쿠키 전송을 비활성화하여 CSRF 403 가능성 제거\n  withCredentials: false\n});\n\n/**\r\n* ✅ 요청 인터셉터\r\n* 모든 요청에 AccessToken 자동 포함\r\n*/\ninstance.interceptors.request.use(config => {\n  const token = localStorage.getItem(\"Authorization\");\n  if (token) {\n    config.headers[\"Authorization\"] = token; // ex) \"Bearer eyJ...\"\n\n    // 디버깅: 요청 시 토큰 페이로드 확인\n    const payload = decodeJwt(token);\n    if (payload) {\n      console.log(\"[auth] request jwt payload:\", payload);\n    }\n  }\n  return config;\n}, error => Promise.reject(error));\n\n/**\r\n* ✅ 응답 인터셉터\r\n* 401(Unauthorized) 발생 시 AccessToken 재발급 처리\r\n*/\ninstance.interceptors.response.use(response => response, async error => {\n  const originalRequest = error.config;\n\n  /**\r\n  * 1️⃣ 로그인/회원가입/아이디찾기 등 비인증 요청은 예외처리\r\n  * -> 세션 만료 메시지 표시 X\r\n  */\n  const unauthenticatedEndpoints = [\"/login\", \"/signup\", \"/find-account\"];\n  if (unauthenticatedEndpoints.some(url => originalRequest.url.includes(url))) {\n    return Promise.reject(error); // 그대로 Login.jsx 등으로 전달\n  }\n\n  /**\r\n  * 2️⃣ AccessToken 만료로 인한 401 에러 처리\r\n  */\n  if (error.response && error.response.status === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    try {\n      // AccessToken 재발급\n      const newAccessToken = await refreshAccessToken();\n      const bearerToken = `Bearer ${newAccessToken}`;\n\n      // 새 토큰 저장\n      localStorage.setItem(\"Authorization\", bearerToken);\n\n      // 요청 헤더 갱신\n      originalRequest.headers[\"Authorization\"] = bearerToken;\n      if (originalRequest.data instanceof FormData && !originalRequest.headers[\"Content-Type\"]) {\n        originalRequest.headers[\"Content-Type\"] = \"multipart/form-data\";\n      }\n\n      // ✅ 재요청 실행 (403 발생 시 권한 부족 가능성 높음)\n      return instance(originalRequest);\n    } catch (refreshError) {\n      console.error(\"❌ refreshToken 재발급 실패:\", refreshError);\n      localStorage.removeItem(\"Authorization\");\n      localStorage.removeItem(\"Authorization-refresh\");\n      localStorage.removeItem(\"userId\");\n      localStorage.removeItem(\"userName\");\n      localStorage.removeItem(\"roleCd\");\n      localStorage.removeItem(\"isLogin\");\n      console.error(\"세션이 만료되었습니다. 다시 로그인해주세요.\");\n      return Promise.reject(refreshError);\n    }\n  }\n\n  // 403인 경우: 인증은 되었으나 권한 부족(AccessDenied) 가능성이 높음\n  if (error.response && error.response.status === 403) {\n    console.warn(\"[auth] 403 Forbidden: 권한 부족 또는 서버 인가 규칙 미스매치 가능성\");\n  }\n  return Promise.reject(error);\n});\nexport default instance;","map":{"version":3,"names":["axios","decodeJwt","bearerToken","token","replace","payload","split","JSON","parse","atob","e","refreshAccessToken","refreshToken","localStorage","getItem","Error","response","post","baseURL","headers","withCredentials","newAccessToken","data","accessToken","console","log","error","instance","create","interceptors","request","use","config","Promise","reject","originalRequest","unauthenticatedEndpoints","some","url","includes","status","_retry","setItem","FormData","refreshError","removeItem","warn"],"sources":["C:/web_ai/react-workspace/STrio_LungMate_FE/frontend/src/token/interceptors.js"],"sourcesContent":["import axios from \"axios\";\r\n\r\n// 디버깅용: JWT Payload 디코드 (개발 중 확인 목적)\r\nconst decodeJwt = (bearerToken) => {\r\n    try {\r\n        if (!bearerToken) return null;\r\n        const token = bearerToken.replace(/^Bearer\\s+/i, \"\");\r\n        const payload = token.split(\".\")[1];\r\n        return JSON.parse(atob(payload));\r\n    } catch (e) {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n* ✅ AccessToken 재발급 함수\r\n* RefreshToken을 이용해 새로운 AccessToken을 발급받습니다.\r\n*/\r\nconst refreshAccessToken = async () => {\r\ntry {\r\n    const refreshToken = localStorage.getItem(\"Authorization-refresh\");\r\n    if (!refreshToken) throw new Error(\"refreshToken 없음\");\r\n\r\n    const response = await axios.post(\r\n    \"/auth/refresh\",\r\n    {},\r\n    {\r\n        baseURL: \"http://localhost:8090\",\r\n        headers: {\r\n        \"Authorization-refresh\": refreshToken,\r\n        },\r\n        // JWT 헤더 기반 인증만 사용하므로 쿠키 전송 비활성화\r\n        withCredentials: false,\r\n    }\r\n    );\r\n\r\n    // 디버깅: 새 토큰 페이로드 출력\r\n    const newAccessToken = response.data.accessToken;\r\n    const payload = decodeJwt(`Bearer ${newAccessToken}`);\r\n    console.log(\"[auth] refreshed access token payload:\", payload);\r\n\r\n    return newAccessToken;\r\n} catch (error) {\r\n    console.error(\"❌ refreshToken 갱신 실패:\", error);\r\n    throw error;\r\n}\r\n};\r\n\r\n/**\r\n* ✅ Axios 공통 인스턴스\r\n*/\r\nconst instance = axios.create({\r\nbaseURL: \"http://localhost:8090\",\r\n// JWT 헤더 기반 인증을 사용하므로 쿠키 전송을 비활성화하여 CSRF 403 가능성 제거\r\nwithCredentials: false,\r\n});\r\n\r\n/**\r\n* ✅ 요청 인터셉터\r\n* 모든 요청에 AccessToken 자동 포함\r\n*/\r\ninstance.interceptors.request.use(\r\n(config) => {\r\n    const token = localStorage.getItem(\"Authorization\");\r\n    if (token) {\r\n    config.headers[\"Authorization\"] = token; // ex) \"Bearer eyJ...\"\r\n    \r\n        // 디버깅: 요청 시 토큰 페이로드 확인\r\n        const payload = decodeJwt(token);\r\n        if (payload) {\r\n            console.log(\"[auth] request jwt payload:\", payload);\r\n        }\r\n    }\r\n    return config;\r\n},\r\n(error) => Promise.reject(error)\r\n);\r\n\r\n/**\r\n* ✅ 응답 인터셉터\r\n* 401(Unauthorized) 발생 시 AccessToken 재발급 처리\r\n*/\r\ninstance.interceptors.response.use(\r\n(response) => response,\r\nasync (error) => {\r\n    const originalRequest = error.config;\r\n\r\n    /**\r\n    * 1️⃣ 로그인/회원가입/아이디찾기 등 비인증 요청은 예외처리\r\n    * -> 세션 만료 메시지 표시 X\r\n    */\r\n    const unauthenticatedEndpoints = [\"/login\", \"/signup\", \"/find-account\"];\r\n    if (unauthenticatedEndpoints.some((url) => originalRequest.url.includes(url))) {\r\n    return Promise.reject(error); // 그대로 Login.jsx 등으로 전달\r\n    }\r\n\r\n    /**\r\n    * 2️⃣ AccessToken 만료로 인한 401 에러 처리\r\n    */\r\n    if (\r\n    error.response &&\r\n    error.response.status === 401 &&\r\n    !originalRequest._retry\r\n    ) {\r\n    originalRequest._retry = true;\r\n\r\n    try {\r\n        // AccessToken 재발급\r\n        const newAccessToken = await refreshAccessToken();\r\n        const bearerToken = `Bearer ${newAccessToken}`;\r\n\r\n        // 새 토큰 저장\r\n        localStorage.setItem(\"Authorization\", bearerToken);\r\n\r\n        // 요청 헤더 갱신\r\n        originalRequest.headers[\"Authorization\"] = bearerToken;\r\n        if (\r\n        originalRequest.data instanceof FormData &&\r\n        !originalRequest.headers[\"Content-Type\"]\r\n        ) {\r\n        originalRequest.headers[\"Content-Type\"] = \"multipart/form-data\";\r\n        }\r\n\r\n        // ✅ 재요청 실행 (403 발생 시 권한 부족 가능성 높음)\r\n        return instance(originalRequest);\r\n    } catch (refreshError) {\r\n        console.error(\"❌ refreshToken 재발급 실패:\", refreshError);\r\n\r\n        localStorage.removeItem(\"Authorization\");\r\n        localStorage.removeItem(\"Authorization-refresh\");\r\n        localStorage.removeItem(\"userId\");\r\n        localStorage.removeItem(\"userName\");\r\n        localStorage.removeItem(\"roleCd\");\r\n        localStorage.removeItem(\"isLogin\");\r\n\r\n        console.error(\"세션이 만료되었습니다. 다시 로그인해주세요.\");\r\n\r\n        return Promise.reject(refreshError);\r\n    }\r\n    }\r\n\r\n        // 403인 경우: 인증은 되었으나 권한 부족(AccessDenied) 가능성이 높음\r\n        if (error.response && error.response.status === 403) {\r\n            console.warn(\"[auth] 403 Forbidden: 권한 부족 또는 서버 인가 규칙 미스매치 가능성\");\r\n        }\r\n\r\n        return Promise.reject(error);\r\n}\r\n);\r\n\r\nexport default instance;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}