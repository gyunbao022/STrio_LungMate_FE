{"ast":null,"code":"import axios from \"axios\";\n\n/**\n* ✅ AccessToken 재발급 함수\n* RefreshToken을 이용해 새로운 AccessToken을 발급받습니다.\n*/\nconst refreshAccessToken = async () => {\n  try {\n    const refreshToken = localStorage.getItem(\"Authorization-refresh\");\n    if (!refreshToken) throw new Error(\"refreshToken 없음\");\n    const response = await axios.post(\"/auth/refresh\", {}, {\n      baseURL: \"http://localhost:8090\",\n      headers: {\n        \"Authorization-refresh\": refreshToken\n      },\n      // JWT 헤더 기반 인증만 사용하므로 쿠키 전송 비활성화\n      withCredentials: false\n    });\n    return response.data.accessToken;\n  } catch (error) {\n    console.error(\"❌ refreshToken 갱신 실패:\", error);\n    throw error;\n  }\n};\n\n/**\n* ✅ Axios 공통 인스턴스\n*/\nconst instance = axios.create({\n  baseURL: \"http://localhost:8090\",\n  // JWT 헤더 기반 인증을 사용하므로 쿠키 전송을 비활성화하여 CSRF 403 가능성 제거\n  withCredentials: false\n});\n\n/**\n* ✅ 요청 인터셉터\n* 모든 요청에 AccessToken 자동 포함\n*/\ninstance.interceptors.request.use(config => {\n  const token = localStorage.getItem(\"Authorization\");\n  if (token) {\n    config.headers[\"Authorization\"] = token; // ex) \"Bearer eyJ...\"\n  }\n  return config;\n}, error => Promise.reject(error));\n\n/**\n* ✅ 응답 인터셉터\n* 401(Unauthorized) 발생 시 AccessToken 재발급 처리\n*/\ninstance.interceptors.response.use(response => response, async error => {\n  const originalRequest = error.config;\n\n  /**\n  * 1️⃣ 로그인/회원가입/아이디찾기 등 비인증 요청은 예외처리\n  * -> 세션 만료 메시지 표시 X\n  */\n  const unauthenticatedEndpoints = [\"/login\", \"/signup\", \"/find-account\"];\n  if (unauthenticatedEndpoints.some(url => originalRequest.url.includes(url))) {\n    return Promise.reject(error); // 그대로 Login.jsx 등으로 전달\n  }\n\n  /**\n  * 2️⃣ AccessToken 만료로 인한 401 에러 처리\n  */\n  if (error.response && error.response.status === 401 && !originalRequest._retry) {\n    originalRequest._retry = true;\n    try {\n      // AccessToken 재발급\n      const newAccessToken = await refreshAccessToken();\n      const bearerToken = `Bearer ${newAccessToken}`;\n\n      // 새 토큰 저장\n      localStorage.setItem(\"Authorization\", bearerToken);\n\n      // 요청 헤더 갱신\n      originalRequest.headers[\"Authorization\"] = bearerToken;\n      if (originalRequest.data instanceof FormData && !originalRequest.headers[\"Content-Type\"]) {\n        originalRequest.headers[\"Content-Type\"] = \"multipart/form-data\";\n      }\n\n      // ✅ 재요청 실행\n      return instance(originalRequest);\n    } catch (refreshError) {\n      console.error(\"❌ refreshToken 재발급 실패:\", refreshError);\n      localStorage.removeItem(\"Authorization\");\n      localStorage.removeItem(\"Authorization-refresh\");\n      localStorage.removeItem(\"userId\");\n      localStorage.removeItem(\"userName\");\n      localStorage.removeItem(\"roleCd\");\n      localStorage.removeItem(\"isLogin\");\n      console.error(\"세션이 만료되었습니다. 다시 로그인해주세요.\");\n      return Promise.reject(refreshError);\n    }\n  }\n  return Promise.reject(error);\n});\nexport default instance;","map":{"version":3,"names":["axios","refreshAccessToken","refreshToken","localStorage","getItem","Error","response","post","baseURL","headers","withCredentials","data","accessToken","error","console","instance","create","interceptors","request","use","config","token","Promise","reject","originalRequest","unauthenticatedEndpoints","some","url","includes","status","_retry","newAccessToken","bearerToken","setItem","FormData","refreshError","removeItem"],"sources":["D:/Medical AI/2nd_project_STrio/frontend/src/token/interceptors.js"],"sourcesContent":["import axios from \"axios\";\n\n/**\n* ✅ AccessToken 재발급 함수\n* RefreshToken을 이용해 새로운 AccessToken을 발급받습니다.\n*/\nconst refreshAccessToken = async () => {\ntry {\n    const refreshToken = localStorage.getItem(\"Authorization-refresh\");\n    if (!refreshToken) throw new Error(\"refreshToken 없음\");\n\n    const response = await axios.post(\n    \"/auth/refresh\",\n    {},\n    {\n        baseURL: \"http://localhost:8090\",\n        headers: {\n        \"Authorization-refresh\": refreshToken,\n        },\n        // JWT 헤더 기반 인증만 사용하므로 쿠키 전송 비활성화\n        withCredentials: false,\n    }\n    );\n\n    return response.data.accessToken;\n} catch (error) {\n    console.error(\"❌ refreshToken 갱신 실패:\", error);\n    throw error;\n}\n};\n\n/**\n* ✅ Axios 공통 인스턴스\n*/\nconst instance = axios.create({\nbaseURL: \"http://localhost:8090\",\n// JWT 헤더 기반 인증을 사용하므로 쿠키 전송을 비활성화하여 CSRF 403 가능성 제거\nwithCredentials: false,\n});\n\n/**\n* ✅ 요청 인터셉터\n* 모든 요청에 AccessToken 자동 포함\n*/\ninstance.interceptors.request.use(\n(config) => {\n    const token = localStorage.getItem(\"Authorization\");\n    if (token) {\n    config.headers[\"Authorization\"] = token; // ex) \"Bearer eyJ...\"\n    }\n    return config;\n},\n(error) => Promise.reject(error)\n);\n\n/**\n* ✅ 응답 인터셉터\n* 401(Unauthorized) 발생 시 AccessToken 재발급 처리\n*/\ninstance.interceptors.response.use(\n(response) => response,\nasync (error) => {\n    const originalRequest = error.config;\n\n    /**\n    * 1️⃣ 로그인/회원가입/아이디찾기 등 비인증 요청은 예외처리\n    * -> 세션 만료 메시지 표시 X\n    */\n    const unauthenticatedEndpoints = [\"/login\", \"/signup\", \"/find-account\"];\n    if (unauthenticatedEndpoints.some((url) => originalRequest.url.includes(url))) {\n    return Promise.reject(error); // 그대로 Login.jsx 등으로 전달\n    }\n\n    /**\n    * 2️⃣ AccessToken 만료로 인한 401 에러 처리\n    */\n    if (\n    error.response &&\n    error.response.status === 401 &&\n    !originalRequest._retry\n    ) {\n    originalRequest._retry = true;\n\n    try {\n        // AccessToken 재발급\n        const newAccessToken = await refreshAccessToken();\n        const bearerToken = `Bearer ${newAccessToken}`;\n\n        // 새 토큰 저장\n        localStorage.setItem(\"Authorization\", bearerToken);\n\n        // 요청 헤더 갱신\n        originalRequest.headers[\"Authorization\"] = bearerToken;\n        if (\n        originalRequest.data instanceof FormData &&\n        !originalRequest.headers[\"Content-Type\"]\n        ) {\n        originalRequest.headers[\"Content-Type\"] = \"multipart/form-data\";\n        }\n\n        // ✅ 재요청 실행\n        return instance(originalRequest);\n    } catch (refreshError) {\n        console.error(\"❌ refreshToken 재발급 실패:\", refreshError);\n\n        localStorage.removeItem(\"Authorization\");\n        localStorage.removeItem(\"Authorization-refresh\");\n        localStorage.removeItem(\"userId\");\n        localStorage.removeItem(\"userName\");\n        localStorage.removeItem(\"roleCd\");\n        localStorage.removeItem(\"isLogin\");\n\n        console.error(\"세션이 만료되었습니다. 다시 로그인해주세요.\");\n\n        return Promise.reject(refreshError);\n    }\n    }\n\n    return Promise.reject(error);\n}\n);\n\nexport default instance;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}