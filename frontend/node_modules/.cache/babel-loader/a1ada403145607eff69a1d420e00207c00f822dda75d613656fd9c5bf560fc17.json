{"ast":null,"code":"import axios from\"axios\";// 디버깅용: JWT Payload 디코드 (개발 중 확인 목적)\nconst decodeJwt=bearerToken=>{try{if(!bearerToken)return null;const token=bearerToken.replace(/^Bearer\\s+/i,\"\");const payload=token.split(\".\")[1];return JSON.parse(atob(payload));}catch(e){return null;}};/**\r\n* ✅ AccessToken 재발급 함수\r\n* RefreshToken을 이용해 새로운 AccessToken을 발급받습니다.\r\n*/const refreshAccessToken=async()=>{try{const refreshToken=localStorage.getItem(\"Authorization-refresh\");if(!refreshToken)throw new Error(\"refreshToken 없음\");const response=await axios.post(\"/auth/refresh\",{},{baseURL:\"http://3.38.231.114:8090\",headers:{\"Authorization-refresh\":refreshToken},// JWT 헤더 기반 인증만 사용하므로 쿠키 전송 비활성화\nwithCredentials:false});// 디버깅: 새 토큰 페이로드 출력\nconst newAccessToken=response.data.accessToken;const payload=decodeJwt(\"Bearer \".concat(newAccessToken));console.log(\"[auth] refreshed access token payload:\",payload);return newAccessToken;}catch(error){console.error(\"❌ refreshToken 갱신 실패:\",error);throw error;}};/**\r\n* ✅ Axios 공통 인스턴스\r\n*/const instance=axios.create({baseURL:\"http://localhost:8090\",// JWT 헤더 기반 인증을 사용하므로 쿠키 전송을 비활성화하여 CSRF 403 가능성 제거\nwithCredentials:false});/**\r\n* ✅ 요청 인터셉터\r\n* 모든 요청에 AccessToken 자동 포함\r\n*/instance.interceptors.request.use(config=>{const token=localStorage.getItem(\"Authorization\");if(token){config.headers[\"Authorization\"]=token;// ex) \"Bearer eyJ...\"\n// 디버깅: 요청 시 토큰 페이로드 확인\nconst payload=decodeJwt(token);if(payload){console.log(\"[auth] request jwt payload:\",payload);}}return config;},error=>Promise.reject(error));/**\r\n* ✅ 응답 인터셉터\r\n* 401(Unauthorized) 발생 시 AccessToken 재발급 처리\r\n*/instance.interceptors.response.use(response=>response,async error=>{const originalRequest=error.config;/**\r\n    * 1️⃣ 로그인/회원가입/아이디찾기 등 비인증 요청은 예외처리\r\n    * -> 세션 만료 메시지 표시 X\r\n    */const unauthenticatedEndpoints=[\"/login\",\"/signup\",\"/find-account\"];if(unauthenticatedEndpoints.some(url=>originalRequest.url.includes(url))){return Promise.reject(error);// 그대로 Login.jsx 등으로 전달\n}/**\r\n    * 2️⃣ AccessToken 만료로 인한 401 에러 처리\r\n    */if(error.response&&error.response.status===401&&!originalRequest._retry){originalRequest._retry=true;try{// AccessToken 재발급\nconst newAccessToken=await refreshAccessToken();const bearerToken=\"Bearer \".concat(newAccessToken);// 새 토큰 저장\nlocalStorage.setItem(\"Authorization\",bearerToken);// 요청 헤더 갱신\noriginalRequest.headers[\"Authorization\"]=bearerToken;if(originalRequest.data instanceof FormData&&!originalRequest.headers[\"Content-Type\"]){originalRequest.headers[\"Content-Type\"]=\"multipart/form-data\";}// ✅ 재요청 실행 (403 발생 시 권한 부족 가능성 높음)\nreturn instance(originalRequest);}catch(refreshError){console.error(\"❌ refreshToken 재발급 실패:\",refreshError);localStorage.removeItem(\"Authorization\");localStorage.removeItem(\"Authorization-refresh\");localStorage.removeItem(\"userId\");localStorage.removeItem(\"userName\");localStorage.removeItem(\"roleCd\");localStorage.removeItem(\"isLogin\");console.error(\"세션이 만료되었습니다. 다시 로그인해주세요.\");return Promise.reject(refreshError);}}// 403인 경우: 인증은 되었으나 권한 부족(AccessDenied) 가능성이 높음\nif(error.response&&error.response.status===403){console.warn(\"[auth] 403 Forbidden: 권한 부족 또는 서버 인가 규칙 미스매치 가능성\");}return Promise.reject(error);});export default instance;","map":{"version":3,"names":["axios","decodeJwt","bearerToken","token","replace","payload","split","JSON","parse","atob","e","refreshAccessToken","refreshToken","localStorage","getItem","Error","response","post","baseURL","headers","withCredentials","newAccessToken","data","accessToken","concat","console","log","error","instance","create","interceptors","request","use","config","Promise","reject","originalRequest","unauthenticatedEndpoints","some","url","includes","status","_retry","setItem","FormData","refreshError","removeItem","warn"],"sources":["C:/web_ai/react-workspace/STrio_LungMate_FE/frontend/src/token/interceptors.js"],"sourcesContent":["import axios from \"axios\";\r\n\r\n// 디버깅용: JWT Payload 디코드 (개발 중 확인 목적)\r\nconst decodeJwt = (bearerToken) => {\r\n    try {\r\n        if (!bearerToken) return null;\r\n        const token = bearerToken.replace(/^Bearer\\s+/i, \"\");\r\n        const payload = token.split(\".\")[1];\r\n        return JSON.parse(atob(payload));\r\n    } catch (e) {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n* ✅ AccessToken 재발급 함수\r\n* RefreshToken을 이용해 새로운 AccessToken을 발급받습니다.\r\n*/\r\nconst refreshAccessToken = async () => {\r\ntry {\r\n    const refreshToken = localStorage.getItem(\"Authorization-refresh\");\r\n    if (!refreshToken) throw new Error(\"refreshToken 없음\");\r\n\r\n    const response = await axios.post(\r\n    \"/auth/refresh\",\r\n    {},\r\n    {\r\n        baseURL: \"http://3.38.231.114:8090\",\r\n        headers: {\r\n        \"Authorization-refresh\": refreshToken,\r\n        },\r\n        // JWT 헤더 기반 인증만 사용하므로 쿠키 전송 비활성화\r\n        withCredentials: false,\r\n    }\r\n    );\r\n\r\n    // 디버깅: 새 토큰 페이로드 출력\r\n    const newAccessToken = response.data.accessToken;\r\n    const payload = decodeJwt(`Bearer ${newAccessToken}`);\r\n    console.log(\"[auth] refreshed access token payload:\", payload);\r\n\r\n    return newAccessToken;\r\n} catch (error) {\r\n    console.error(\"❌ refreshToken 갱신 실패:\", error);\r\n    throw error;\r\n}\r\n};\r\n\r\n/**\r\n* ✅ Axios 공통 인스턴스\r\n*/\r\nconst instance = axios.create({\r\nbaseURL: \"http://localhost:8090\",\r\n// JWT 헤더 기반 인증을 사용하므로 쿠키 전송을 비활성화하여 CSRF 403 가능성 제거\r\nwithCredentials: false,\r\n});\r\n\r\n/**\r\n* ✅ 요청 인터셉터\r\n* 모든 요청에 AccessToken 자동 포함\r\n*/\r\ninstance.interceptors.request.use(\r\n(config) => {\r\n    const token = localStorage.getItem(\"Authorization\");\r\n    if (token) {\r\n    config.headers[\"Authorization\"] = token; // ex) \"Bearer eyJ...\"\r\n    \r\n        // 디버깅: 요청 시 토큰 페이로드 확인\r\n        const payload = decodeJwt(token);\r\n        if (payload) {\r\n            console.log(\"[auth] request jwt payload:\", payload);\r\n        }\r\n    }\r\n    return config;\r\n},\r\n(error) => Promise.reject(error)\r\n);\r\n\r\n/**\r\n* ✅ 응답 인터셉터\r\n* 401(Unauthorized) 발생 시 AccessToken 재발급 처리\r\n*/\r\ninstance.interceptors.response.use(\r\n(response) => response,\r\nasync (error) => {\r\n    const originalRequest = error.config;\r\n\r\n    /**\r\n    * 1️⃣ 로그인/회원가입/아이디찾기 등 비인증 요청은 예외처리\r\n    * -> 세션 만료 메시지 표시 X\r\n    */\r\n    const unauthenticatedEndpoints = [\"/login\", \"/signup\", \"/find-account\"];\r\n    if (unauthenticatedEndpoints.some((url) => originalRequest.url.includes(url))) {\r\n    return Promise.reject(error); // 그대로 Login.jsx 등으로 전달\r\n    }\r\n\r\n    /**\r\n    * 2️⃣ AccessToken 만료로 인한 401 에러 처리\r\n    */\r\n    if (\r\n    error.response &&\r\n    error.response.status === 401 &&\r\n    !originalRequest._retry\r\n    ) {\r\n    originalRequest._retry = true;\r\n\r\n    try {\r\n        // AccessToken 재발급\r\n        const newAccessToken = await refreshAccessToken();\r\n        const bearerToken = `Bearer ${newAccessToken}`;\r\n\r\n        // 새 토큰 저장\r\n        localStorage.setItem(\"Authorization\", bearerToken);\r\n\r\n        // 요청 헤더 갱신\r\n        originalRequest.headers[\"Authorization\"] = bearerToken;\r\n        if (\r\n        originalRequest.data instanceof FormData &&\r\n        !originalRequest.headers[\"Content-Type\"]\r\n        ) {\r\n        originalRequest.headers[\"Content-Type\"] = \"multipart/form-data\";\r\n        }\r\n\r\n        // ✅ 재요청 실행 (403 발생 시 권한 부족 가능성 높음)\r\n        return instance(originalRequest);\r\n    } catch (refreshError) {\r\n        console.error(\"❌ refreshToken 재발급 실패:\", refreshError);\r\n\r\n        localStorage.removeItem(\"Authorization\");\r\n        localStorage.removeItem(\"Authorization-refresh\");\r\n        localStorage.removeItem(\"userId\");\r\n        localStorage.removeItem(\"userName\");\r\n        localStorage.removeItem(\"roleCd\");\r\n        localStorage.removeItem(\"isLogin\");\r\n\r\n        console.error(\"세션이 만료되었습니다. 다시 로그인해주세요.\");\r\n\r\n        return Promise.reject(refreshError);\r\n    }\r\n    }\r\n\r\n        // 403인 경우: 인증은 되었으나 권한 부족(AccessDenied) 가능성이 높음\r\n        if (error.response && error.response.status === 403) {\r\n            console.warn(\"[auth] 403 Forbidden: 권한 부족 또는 서버 인가 규칙 미스매치 가능성\");\r\n        }\r\n\r\n        return Promise.reject(error);\r\n}\r\n);\r\n\r\nexport default instance;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}